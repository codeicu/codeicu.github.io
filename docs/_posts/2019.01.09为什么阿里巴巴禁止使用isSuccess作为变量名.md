---
title: 为什么阿里巴巴禁止使用isSuccess作为变量名
date: 2019-01-09 10:33:06
tags: Java
---
- 今天在Hollis读到一篇[好文](https://mp.weixin.qq.com/s/LTiN6800FbIPmG2UdWwqqg)，摘录如下：


<div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="margin: 5px 16px;font-variant-numeric: normal;font-variant-east-asian: normal;letter-spacing: 0.544px;white-space: normal;widows: 1;word-spacing: 2px;text-align: center;line-height: 1.5em;background-color: rgb(255, 255, 255);" data-mpa-powered-by="yiban.io"><span style="font-size: 13px;letter-spacing: 0.544px;color: rgb(136, 136, 136);">点击上方</span><span style="font-size: 13px;letter-spacing: 0.544px;">“</span><span style="font-size: 13px;letter-spacing: 0.544px;color: rgb(0, 82, 255);">Java后端技术</span><span style="font-size: 13px;letter-spacing: 0.544px;">”，</span><span style="font-size: 13px;letter-spacing: 0.544px;color: rgb(136, 136, 136);">选择“置顶或者星标”</span></p><p style="margin: 5px 16px 15px;font-variant-numeric: normal;font-variant-east-asian: normal;letter-spacing: 0.544px;white-space: normal;widows: 1;text-align: center;line-height: 1.5em;background-color: rgb(255, 255, 255);"><span style="color: rgb(127, 127, 127);letter-spacing: 0.544px;font-size: 13px;">每天带你看高清大图哦！</span></p><p style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="" data-backh="371" data-backw="556" data-before-oversubscription-url="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GNmC1lklLdkWVqjRviaenePdk2VbjobM2lJBX6LpB5y1JZUciadgCXZMw/640?wx_fmt=jpeg" data-copyright="0" data-cropselx1="0" data-cropselx2="556" data-cropsely1="0" data-cropsely2="371" data-ratio="0.66640625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GNmC1lklLdkWVqjRviaenePdk2VbjobM2lJBX6LpB5y1JZUciadgCXZMw/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" style="visibility: visible !important; width: 100% !important; height: auto !important;" _width="100%" src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GNmC1lklLdkWVqjRviaenePdk2VbjobM2lJBX6LpB5y1JZUciadgCXZMw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;line-height: normal;margin-bottom: 20px;"><span style="font-size: 14px;color: rgb(136, 136, 136);"></span><span style="color: rgb(136, 136, 136);letter-spacing: 0.544px;text-align: center;background-color: rgb(255, 255, 255);font-size: 14px;">作者：Hollis | 微信公众号：Hollis</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在日常开发中，我们会经常要在类中定义布尔类型的变量，比如在给外部系统提供一个RPC接口的时候，我们一般会定义一个字段表示本次请求是否成功的。<br></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">关于这个”本次请求是否成功”的字段的定义，其实是有很多种讲究和坑的，稍有不慎就会掉入坑里，作者在很久之前就遇到过类似的问题，本文就来围绕这个简单分析一下。到底该如何定一个布尔类型的成员变量。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">一般情况下，我们可以有以下四种方式来定义一个布尔类型的成员变量：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.28488372093023256" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GXUrAcnSnoDRib81akib1FzCWfYIzZ00e9lBNXKbonTibYDY5su81mJgUg/640?wx_fmt=png" data-type="png" data-w="344" style="width: 344px !important; height: auto !important; visibility: visible !important;" _width="344px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GXUrAcnSnoDRib81akib1FzCWfYIzZ00e9lBNXKbonTibYDY5su81mJgUg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上四种定义形式，你日常开发中最常用的是哪种呢？</span><span style="font-size: 16px;color: rgb(255, 0, 0);"><strong>到底哪一种才是正确的使用姿势呢？</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">通过观察我们可以发现：前两种和后两种的主要区别是变量的类型不同，前者使用的是boolean，后者使用的是Boolean。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">另外，第一种和第三种在定义变量的时候，变量命名是success，而另外两种使用isSuccess来命名的。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">首先，</span><strong><span style="font-size: 16px;color: rgb(255, 0, 0);">我们来分析一下，到底应该是用success来命名，还是使用isSuccess更好一点。</span></strong></p><section class="" data-mpa-template-id="1465733" data-mpa-color="null" data-mpa-category="收藏"><section><section class=""><section style="margin: 1em 0px;color: rgb(51, 51, 51);box-sizing:border-box;border-bottom-width: 2px;border-bottom-style: solid;border-bottom-color: rgb(236, 68, 68);clear: both;"><section style="display: inline-block;padding:3px 10px 0px;color: rgb(255, 255, 255);box-sizing:border-box;border-top-left-radius: 3px;border-top-right-radius: 3px;height: 28px;background-color: rgb(236, 68, 68);" mpa-is-content="t"><span style="font-size: 16px;">一、success 还是 isSucces</span></section><section style="box-sizing:border-box;border-top-width:28px;border-top-style: solid;border-color: transparent rgb(206,206,206);border-bottom-width: 0px;border-bottom-style: solid;border-left-width: 15px;border-left-style: solid;display: inline-block;margin-left:2px;vertical-align:top;"></section></section></section></section></section><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">到底应该是用success还是isSuccess来给变量命名呢？从语义上面来讲，两种命名方式都可以讲的通，并且也都没有歧义。那么还有什么原则可以参考来让我们做选择呢。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在阿里巴巴Java开发手册中关于这一点，有过一个『强制性』规定：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.125" data-type="jpeg" data-w="1312" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hvtJwCkPMLcB3ZBCrsOG54cwYCfYaHibI5SelU20hQGg5lDrzLEhnjuw/640?wx_fmt=jpeg" style="visibility: visible !important; width: 677px !important; height: auto !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hvtJwCkPMLcB3ZBCrsOG54cwYCfYaHibI5SelU20hQGg5lDrzLEhnjuw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"><span style="font-size: 16px;">￼<br>那么，为什么会有这样的规定呢？我们看一下POJO中布尔类型变量不同的命名有什么区别吧。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="2.14987714987715" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G182w5ZBHt82j8BL0AYoia4woVtj6JoLUFbeBwXQ1Oy53Uho7vOYwpTQ/640?wx_fmt=png" data-type="png" data-w="407" style="width: 407px !important; height: auto !important; visibility: visible !important;" _width="407px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G182w5ZBHt82j8BL0AYoia4woVtj6JoLUFbeBwXQ1Oy53Uho7vOYwpTQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上代码的setter/getter是使用Intellij IDEA自动生成的，仔细观察以上代码，你会发现以下规律：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">基本类型自动生成的getter和setter方法，名称都是isXXX()和setXXX()形式的。</span></p></li><li><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">包装类型自动生成的getter和setter方法，名称都是getXXX()和setXXX()形式的。</span></p></li></ul><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">既然，我们已经达成一致共识使用基本类型boolean来定义成员变量了，那么我们再来具体看下Model3和Model4中的setter/getter有何区别。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">我们可以发现，虽然Model3和Model4中的成员变量的名称不同，一个是success，另外一个是isSuccess，但是他们自动生成的getter和setter方法名称都是isSuccess和setSuccess。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="color: rgb(255, 0, 0);font-size: 16px;"><strong>Java Bean中关于setter/getter的规范</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">关于Java Bean中的getter/setter方法的定义其实是有明确的规定的，根据JavaBeans(TM) Specification规定，如果是普通的参数，命名为propertyName，需要通过以下方式定义其setter/getter：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.1244343891402715" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GYib66HVjwhfJHqIzvY51XI5ejNl5Qm70ygvOACibf3ZOcZ7JRmVcwtww/640?wx_fmt=png" data-type="png" data-w="442" style="width: 442px !important; height: auto !important; visibility: visible !important;" _width="442px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GYib66HVjwhfJHqIzvY51XI5ejNl5Qm70ygvOACibf3ZOcZ7JRmVcwtww/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">但是，布尔类型的变量propertyName则是另外一套命名原则的：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.13520408163265307" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G8d3FxRxlxPmVzZpFhM794pL2QHqPXXVsuOXCibpVjw6RDSIa2UDxDjw/640?wx_fmt=png" data-type="png" data-w="392" style="width: 392px !important; height: auto !important; visibility: visible !important;" _width="392px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G8d3FxRxlxPmVzZpFhM794pL2QHqPXXVsuOXCibpVjw6RDSIa2UDxDjw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p><img class="" data-ratio="0.34934497816593885" data-type="jpeg" data-w="1374" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hcdIH11cxFMsIyIF1SUj5ibozblkIqjMhzJtl0IdccTMEf0SbWlBmSeg/640?wx_fmt=jpeg" style="margin-top: 5px; margin-bottom: 5px; border-width: 0px; border-style: initial; border-color: initial; vertical-align: middle; display: block; visibility: visible !important; width: 677px !important; height: auto !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hcdIH11cxFMsIyIF1SUj5ibozblkIqjMhzJtl0IdccTMEf0SbWlBmSeg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">通过对照这份JavaBeans规范，我们发现，在Model4中，变量名为isSuccess，如果严格按照规范定义的话，他的getter方法应该叫isIsSuccess。但是很多IDE都会默认生成为isSuccess。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;"><strong><span style="font-size: 16px;color: rgb(255, 0, 0);">那这样做会带来什么问题呢？</span></strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在一般情况下，其实是没有影响的。但是有一种特殊情况就会有问题，那就是发生序列化的时候。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="color: rgb(255, 0, 0);font-size: 16px;"><strong>序列化带来的影响</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">我们这里拿比较常用的JSON序列化来举例，看看常用的fastJson、jackson和Gson之间有何区别：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="1.1173402868318123" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G6UviaDH9Hlk6BooUjmnJ9C9sUOFHjHliazNmWcnGC2N1yTKpEgHnFEfQ/640?wx_fmt=png" data-type="png" data-w="767" style="width: 677px !important; height: auto !important; visibility: visible !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G6UviaDH9Hlk6BooUjmnJ9C9sUOFHjHliazNmWcnGC2N1yTKpEgHnFEfQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上代码的Model3中，只有一个成员变量即isSuccess，三个方法，分别是IDE帮我们自动生成的isSuccess和setSuccess，另外一个是作者自己增加的一个符合getter命名规范的方法。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上代码输出结果：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.13821138211382114" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7Gzj84JexVoTRyg1Zv6tQtKgug7PIic01IGicZZOAzj7icicaGd9liczUXRfQ/640?wx_fmt=png" data-type="png" data-w="615" style="width: 615px !important; height: auto !important; visibility: visible !important;" _width="615px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7Gzj84JexVoTRyg1Zv6tQtKgug7PIic01IGicZZOAzj7icicaGd9liczUXRfQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在fastjson和jackson的结果中，原来类中的isSuccess字段被序列化成success，并且其中还包含hollis值。而Gson中只有isSuccess字段。<br></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">我们可以得出结论：fastjson和jackson在把对象序列化成json字符串的时候，是通过反射遍历出该类中的所有getter方法，得到getHollis和isSuccess，然后根据JavaBeans规则，他会认为这是两个属性hollis和success的值。直接序列化成json:</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.1184573002754821" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G7jiaUpwXwF2v6icffzjzgzVVplB6FEAViauRqpaOanHaf4WM8Tx5Vadgw/640?wx_fmt=png" data-type="png" data-w="363" style="width: 363px !important; height: auto !important; visibility: visible !important;" _width="363px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G7jiaUpwXwF2v6icffzjzgzVVplB6FEAViauRqpaOanHaf4WM8Tx5Vadgw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">但是Gson并不是这么做的，他是通过反射遍历该类中的所有属性，并把其值序列化成json:</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.12612612612612611" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GayR0v2ZOINSUBN64oD0YrVyJ6sOrX0HjuibMqSvu7MwxLhKLB5Z1PQw/640?wx_fmt=png" data-type="png" data-w="333" style="width: 333px !important; height: auto !important; visibility: visible !important;" _width="333px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GayR0v2ZOINSUBN64oD0YrVyJ6sOrX0HjuibMqSvu7MwxLhKLB5Z1PQw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">可以看到，由于不同的序列化工具，在进行序列化的时候使用到的策略是不一样的，所以，对于同一个类的同一个对象的序列化结果可能是不同的。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">前面提到的关于对getHollis的序列化只是为了说明fastjson、jackson和Gson之间的序列化策略的不同，我们暂且把他放到一边，我们把他从Model3中删除后，重新执行下以上代码，得到结果：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.1762114537444934" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GJ4Xg0DNcnZBFCia0x5iaHR5uVMnYOm5XTzxEsOMLadNhe1A4TLAYPz2A/640?wx_fmt=png" data-type="png" data-w="454" style="width: 454px !important; height: auto !important; visibility: visible !important;" _width="454px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GJ4Xg0DNcnZBFCia0x5iaHR5uVMnYOm5XTzxEsOMLadNhe1A4TLAYPz2A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">现在，不同的序列化框架得到的json内容并不相同，如果对于同一个对象，我使用fastjson进行序列化，再使用Gson反序列化会发生什么？</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.8755690440060698" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G6PxEjpTVjJ3wq89T917QZGIfS2Y8swJrONwEEFFO4NOkv3QRITWWDA/640?wx_fmt=png" data-type="png" data-w="659" style="width: 659px !important; height: auto !important; visibility: visible !important;" _width="659px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G6PxEjpTVjJ3wq89T917QZGIfS2Y8swJrONwEEFFO4NOkv3QRITWWDA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上代码，输出结果：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.1076923076923077" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GIvkxwuax5Ria6iadN849Vw6L8LxYtXssyZQ8fbp8icyX3q5HpOic769low/640?wx_fmt=png" data-type="png" data-w="325" style="width: 325px !important; height: 35px !important;" _width="325px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">这和我们预期的结果完全相反，原因是因为JSON框架通过扫描所有的getter后发现有一个isSuccess方法，然后根据JavaBeans的规范，解析出变量名为success，把model对象序列化城字符串后内容为{"success":true}。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">根据{"success":true}这个json串，Gson框架在通过解析后，通过反射寻找Model类中的success属性，但是Model类中只有isSuccess属性，所以，最终反序列化后的Model类的对象中，isSuccess则会使用默认值false。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><strong><span style="font-size: 16px;">但是，一旦以上代码发生在生产环境，这绝对是一个致命的问题。</span></strong></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">所以，作为开发者，我们应该想办法尽量避免这种问题的发生，对于POJO的设计者来说，只需要做简单的一件事就可以解决这个问题了，那就是把isSuccess改为success。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">这样，该类里面的成员变量时success，getter方法是isSuccess，这是完全符合JavaBeans规范的。无论哪种序列化框架，执行结果都一样。就从源头避免了这个问题。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;"><strong><span style="font-size: 16px;color: rgb(255, 0, 0);">引用一下R大关于阿里巴巴Java开发手册中这条规定的评价</span></strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">（https://www.zhihu.com/question/55642203）</span></p><p><img class="" data-ratio="0.3548872180451128" data-type="jpeg" data-w="1330" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hWngkERqgA61eMQI7P84aaCv6CdyxRoxtLWRCyD6SSBwevOziaJn7Gkg/640?wx_fmt=jpeg" style="margin-top: 5px; margin-bottom: 5px; background-color: rgb(238, 237, 235); border-width: 0px; border-style: initial; border-color: initial; background-size: 22px auto; background-position: center center; background-repeat: no-repeat; vertical-align: middle; display: block; width: 677px !important; height: auto !important; visibility: visible !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hWngkERqgA61eMQI7P84aaCv6CdyxRoxtLWRCyD6SSBwevOziaJn7Gkg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">￼所以，在定义POJO中的布尔类型的变量时，不要使用isSuccess这种形式，而要直接使用success！</span></p><section class="" data-mpa-template-id="1465733" data-mpa-color="null" data-mpa-category="收藏"><section><section class=""><section style="margin: 1em 0px;color: rgb(51, 51, 51);box-sizing:border-box;border-bottom-width: 2px;border-bottom-style: solid;border-bottom-color: rgb(236, 68, 68);clear: both;"><section style="display: inline-block;padding:3px 10px 0px;color: rgb(255, 255, 255);box-sizing:border-box;border-top-left-radius: 3px;border-top-right-radius: 3px;height: 28px;background-color: rgb(236, 68, 68);" mpa-is-content="t"><span style="font-size: 16px;">二、Boolean还是boolean？</span></section><section style="box-sizing:border-box;border-top-width:28px;border-top-style: solid;border-color: transparent rgb(206,206,206);border-bottom-width: 0px;border-bottom-style: solid;border-left-width: 15px;border-left-style: solid;display: inline-block;margin-left:2px;vertical-align:top;"></section></section></section></section></section><section class="" data-mpa-template-id="1120346" data-mpa-color="null" data-mpa-category="收藏"><section data-mpa-template-id="1115154" data-mpa-color="null" data-mpa-category="fav"><section><section><section class="" data-mpa-template-id="1120345" data-mpa-color="null" data-mpa-category="fav"><section><section class="" powered-by="xiumi.us"><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">前面我们介绍完了在success和isSuccess之间如何选择，那么排除错误答案后，备选项还剩下：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.17771084337349397" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GVOtq1WdhKyuCea3Y7ZlqNH9OUzjhLKzib2HYQqokKk3cZhFmAJg7GhQ/640?wx_fmt=png" data-type="png" data-w="332" style="width: 332px !important; height: auto !important; visibility: visible !important;" _width="332px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7GVOtq1WdhKyuCea3Y7ZlqNH9OUzjhLKzib2HYQqokKk3cZhFmAJg7GhQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">那么，到底应该是用Boolean还是boolean来给定一个布尔类型的变量呢？我们知道，boolean是基本数据类型，而Boolean是包装类型。那么，在定义一个成员变量的时候到底是使用包装类型更好还是使用基本数据类型呢？我们来看一段简单的代码：</span></p></section></section></section></section></section></section></section><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="1.1783960720130933" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G80mH0RkXQvzZiasrQVicicdPMWIrGibJyZMibiaKXwOAEfnyMZZQqZJ2dKyA/640?wx_fmt=png" data-type="png" data-w="611" style="width: 611px !important; height: auto !important; visibility: visible !important;" _width="611px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7G80mH0RkXQvzZiasrQVicicdPMWIrGibJyZMibiaKXwOAEfnyMZZQqZJ2dKyA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">以上代码输出结果为：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.09567198177676538" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7Gb0TpPlkHSfuI24kxLI6Hjdic8Zex5B3GRhYfwbJKej9B54LWXBo4qKQ/640?wx_fmt=png" data-type="png" data-w="439" style="width: 439px !important; height: auto !important; visibility: visible !important;" _width="439px" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdbWK7oaVRc9CHbSVK0TibM7Gb0TpPlkHSfuI24kxLI6Hjdic8Zex5B3GRhYfwbJKej9B54LWXBo4qKQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">可以看到，当我们没有设置Model对象的字段的值的时候，Boolean类型的变量会设置默认值为null，而boolean类型的变量会设置默认值为false。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;"><strong>即对象的默认值是null，boolean基本数据类型的默认值是false。</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在阿里巴巴Java开发手册中，对于POJO中如何选择变量的类型也有着一些规定：</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><img class="" data-ratio="0.41201716738197425" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Icde0gUhgRiaWPyWUZxVw9tlnN5PmTQe0CHPtAciayGz4P2gQtPMgVRA79uaeID7x3HlkATNQy4kgA/640?wx_fmt=png" data-type="png" data-w="1864" style="width: 677px !important; height: auto !important; visibility: visible !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Icde0gUhgRiaWPyWUZxVw9tlnN5PmTQe0CHPtAciayGz4P2gQtPMgVRA79uaeID7x3HlkATNQy4kgA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="color: rgb(255, 0, 0);font-size: 16px;"><strong>这里建议我们使用包装类型，原因是什么呢？</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">举一个扣费的例子，我们做一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额*费率=费用 进行计算，计算结果进行划扣。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;"><strong>以上，就是建议在POJO和RPC的返回值中使用包装类型的原因。</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">在之前那篇文章的解析中，作者的观点是，对于布尔类型的变量，我认为可以和其他类型区分开来，作者并不认为使用null进而导致NPE是一种最好的实践。因为布尔类型只有true/false两种值，我们完全可以和外部调用方约定好当返回值为false时的明确语义。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">所以之前建议大家使用boolean来定义success变量，后来有读者评论或者私下和我沟通，关于这部分内容又有了一些新的思考。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">后来，作者单独和《阿里巴巴Java开发手册》、《码出高效》的作者——孤尽 单独1V1(qing) Battle(jiao)了一下。最终达成共识，还是尽量使用包装类型。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">但是，作者还是想强调一个我的观点，尽量避免在你的代码中出现不确定的null值。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="color: rgb(255, 0, 0);font-size: 16px;"><strong>null何罪之有？</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;"><strong>null是很模棱两可的，很多时候会导致令人疑惑的错误，很难去判断返回一个null代表着什么意思。</strong></span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">图灵奖得主Tony Hoare 曾经公开表达过null是一个糟糕的设计。</span></p><p><img class="" data-ratio="0.47058823529411764" data-type="jpeg" data-w="850" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hDbe2iagKOkqUbcT5MQ9RWobPxmG814xTBeuHxiauwTTrT1LaGFpGPJow/640?wx_fmt=jpeg" style="margin-top: 5px; margin-bottom: 5px; border-width: 0px; border-style: initial; border-color: initial; vertical-align: middle; display: block; visibility: visible !important; width: 677px !important; height: auto !important;" _width="677px" src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KlsGFye0GlG52tuFbexJ9hDbe2iagKOkqUbcT5MQ9RWobPxmG814xTBeuHxiauwTTrT1LaGFpGPJow/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0"></p><section class="" data-mpa-template-id="1434560" data-mpa-color="null" data-mpa-category="收藏"><section class="" label="powered by 135editor.com"><section class=""><section><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">我把 null 引用称为自己的十亿美元错误。它的发明是在1965 年，那时我用一个面向对象语言( ALGOL W )设计了第一个全面的引用类型系统。我的目的是确保所有引用的使用都是绝对安全的，编译器会自动进行检查。但是我未能抵御住诱惑，加入了Null引用，仅仅是因为实现起来非常容易。它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失。</span></p></section></section></section></section><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">当我们在设计一个接口的时候，对于接口的返回值的定义，尽量避免使用Boolean类型来定义。大多数情况下，别人使用我们的接口返回值时可能用if(response.isSuccess){}else{}的方式，如果我们由于忽略没有设置success字段的值，就可能导致NPE，这明显是我们不希望看到的。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">当然，编程中并没有绝对。两种方式是两种思维方式，多提供一种思路，供读者们在日常开发中自行选择。</span></p><section class="" data-mpa-template-id="1465733" data-mpa-color="null" data-mpa-category="收藏"><section><section class=""><section style="margin: 1em 0px;color: rgb(51, 51, 51);box-sizing:border-box;border-bottom-width: 2px;border-bottom-style: solid;border-bottom-color: rgb(236, 68, 68);clear: both;"><section style="display: inline-block;padding:3px 10px 0px;color: rgb(255, 255, 255);box-sizing:border-box;border-top-left-radius: 3px;border-top-right-radius: 3px;height: 28px;background-color: rgb(236, 68, 68);" mpa-is-content="t"><span style="font-size: 16px;">三、总结</span></section><section style="box-sizing:border-box;border-top-width:28px;border-top-style: solid;border-color: transparent rgb(206,206,206);border-bottom-width: 0px;border-bottom-style: solid;border-left-width: 15px;border-left-style: solid;display: inline-block;margin-left:2px;vertical-align:top;"></section></section></section></section></section><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">本文围绕布尔类型的变量定义的类型和命名展开了介绍，最终我们可以得出结论，在定义一个布尔类型的变量，尤其是一个给外部提供的接口返回值时，要使用success来命名，阿里巴巴Java开发手册建议使用封装类来定义POJO和RPC返回值中的变量。但是这不意味着可以随意的使用null，我们还是要尽量避免出现对null的处理的。</span></p><p style="margin-top: 15px;margin-bottom: 15px;line-height: 2em;"><span style="font-size: 16px;">好啦，以上就是关于POJO中布尔类型变量的正确定义姿势。你用对了么？</span></p><p style="margin-top: 20px;margin-bottom: 20px;letter-spacing: 0.544px;white-space: normal;font-family: 微软雅黑;background-color: rgb(255, 255, 255);font-size: 16px;line-height: 1.7;"><span style="font-size: 14px;"><strong style="letter-spacing: 0.544px;word-spacing: 2px;font-family: -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">热门内容：</strong><br></span></p><section class="" data-mpa-template-id="1480331" data-mpa-color="null" data-mpa-category="fav" style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);"><section class="" data-tools="135编辑器" data-id="89715" style="font-size: 16px;border-width: 0px;border-style: none;border-color: initial;"><section class="" data-mpa-template-id="1252" data-mpa-color="#ffffff" data-mpa-category="divider" style="color: rgb(62, 62, 62);font-size: 14px;letter-spacing: 0.5px;word-spacing: 2px;"><section><section class="" powered-by="xiumi.us" style="color: rgb(51, 51, 51);font-size: 17px;letter-spacing: 0.544px;"><section class=""><section class=""><section class="" data-mpa-template-id="1000" data-mpa-color="#ffffff" data-mpa-category="bottom_guide"><section><section style="margin-top: 0.5em;margin-bottom: 0.5em;"><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">1、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488094&amp;idx=1&amp;sn=493115bd9e5a4a07dd58087fa284e7cb&amp;chksm=e9c5ebefdeb262f9b9e82cdc36f7ca0a3bf54c2cacf49aac37ebbd1a6107e66601753b658603&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2">房东：你敢申报，我就涨房租！今冬，我一个程序员朋友离开了北京……</a></span></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">2、<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488065&amp;idx=1&amp;sn=6d407bbd54d70a31b68ab3366b747d55&amp;chksm=e9c5ebf0deb262e6d075a7272d45a1ad1fa5003d22dba448866b8568e7277f237f8a4008752d&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2">程序员的这 10 个坏习惯！你占了几个？</a></span></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">3、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488060&amp;idx=1&amp;sn=de35ce2480bf3de48ab56d24b0ff1ded&amp;chksm=e9c5eb8ddeb2629b8c7075fa0fa8fffddb494bead0bcc3ef10fe64fe998819e8b8231d3cc290&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;text-decoration: none;"><span style="font-size: 14px;">为什么大公司要设置这么高的门槛？</span></a></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">4、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488049&amp;idx=2&amp;sn=2d4310e17822523dc79120c9d92a1147&amp;chksm=e9c5eb80deb262962becbaf57a8c646c602548512dd3946499dd13dd9a2fb8fae77dc13055ca&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;text-decoration: none;"><span style="font-size: 14px;">北京后厂村程序员：月薪追赶五万，生活低于五千！</span></a></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">5、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488037&amp;idx=1&amp;sn=e03130097b448458b4cee25d38a948ad&amp;chksm=e9c5eb94deb262828dc9f6269238736bc6c47e9dc4840736d6be733daa0d540d23efd73a85a8&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;text-decoration: none;"><span style="font-size: 14px;">数据库中为什么不推荐使用外键约束？</span></a></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">6、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247488004&amp;idx=1&amp;sn=0a297a4d35090571fcf3f297016dafed&amp;chksm=e9c5ebb5deb262a31d83d75f5f5724e8f73b31ab7f12ee519c4ec416ae77638ae69a2b87c19a&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;text-decoration: none;"><span style="font-size: 14px;">为什么阿里巴巴禁止直接使用日志系统中的 API？</span></a></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">7、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247487977&amp;idx=1&amp;sn=f893a169f8232bf08035ac1ed260a089&amp;chksm=e9c5e858deb2614e9c94f2c2d0e0da9b99fd76f98ad5395f12430c427bb36b7633516a2fbf81&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;text-decoration: none;"><span style="font-size: 14px;">你的系统可靠性和可用性是几个9?</span></a></p><p style="margin-top: 10px;margin-bottom: 10px;text-align: left;line-height: 1.75em;"><span style="font-size: 14px;text-decoration: none;">8、</span><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247487976&amp;idx=1&amp;sn=b875b9737d1ca71384db5645ee2d500a&amp;chksm=e9c5e859deb2614fc35fe33915a00d8cb83c8129c57fc809a34d20c4bf3d9fee409ae6cffce3&amp;scene=21#wechat_redirect" target="_blank" data-linktype="2" style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);text-decoration: none;"><span style="color: rgb(87, 107, 149);-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;">Maven的这三个用法你一定要会！</span><br></a></p></section></section></section></section></section><span style="letter-spacing: 0.544px;width: auto !important;"><img class="" data-copyright="0" data-ratio="0.5" data-s="300,640" data-type="png" data-w="800" data-src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLda8TWB0rCPDRObrOHuCRKNtndsCNwbsMejpEvEwWTibrcy9xhLbFwbOCarFP5NrZTOZtzGFjeLh6yg/640?" style="letter-spacing: 0.544px; text-align: center; visibility: visible !important; width: auto !important; height: auto !important;" _width="auto" src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLda8TWB0rCPDRObrOHuCRKNtndsCNwbsMejpEvEwWTibrcy9xhLbFwbOCarFP5NrZTOZtzGFjeLh6yg/640?wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" crossorigin="anonymous" data-fail="0" width="auto"></span></section></section></section></section></section>
                </div>
